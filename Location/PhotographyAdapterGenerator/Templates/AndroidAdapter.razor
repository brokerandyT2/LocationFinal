
/**
 * This is a truly stupid adapter that just bridges stuff.
 * It should never be smart. Ever.
 * (Now even more stupid because Akavache handles all the caching!)
 *
 * Generated from: @Model.FullName
 * Source: @model.Source
 * Generated: @DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss UTC")
 */

package com.3xSquaredCircles.photography.NoOpViewModelAdapters

import androidx.lifecycle.ViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.withContext
import javax.inject.Inject
import kotlin.Result

class @model.AdapterName @Raw("@Inject") constructor(
    private val dotnetViewModel: @model.FullName
) : ViewModel() {

@foreach (var prop in model.Properties.Where(p => !p.IsObservableCollection))
{
    @:// Direct property access - let .NET handle threading
    @:val @prop.CamelCaseName: @model.GetKotlinType(prop.Type) get() = dotnetViewModel.@prop.Name
    @:
}

@foreach (var collection in model.Properties.Where(p => p.IsObservableCollection))
{
    @:// ObservableCollection<@(collection.ElementType?.Name ?? "Unknown")> → StateFlow<List<@model.GetKotlinType(collection.ElementType)>>
    @:private val _@collection.CamelCaseName = MutableStateFlow<List<@model.GetKotlinType(collection.ElementType)>>(emptyList())
    @:val @collection.CamelCaseName: StateFlow<List<@model.GetKotlinType(collection.ElementType)>> = _@collection.CamelCaseName.asStateFlow()
    @:
}

@foreach (var command in model.Commands)
{
    @if (command.IsAsync)
    {
        @:// Async command: @command.Name - let .NET handle threading
        @:suspend fun @command.MethodName(@model.GetParameterSignature(command)): Result<Unit> = withContext(Dispatchers.IO) {
        @:    return try {
        @if (command.HasParameter)
        {
            @:        dotnetViewModel.@command.Name.executeAsync(@model.GetParameterName(command))
        }
        else
        {
            @:        dotnetViewModel.@command.Name.executeAsync()
        }
        @:        Result.success(Unit)
        @:    } catch (e: Exception) {
        @:        Result.failure(e)
        @:    }
        @:}
        @:
    }
    else
    {
        @:// Sync command: @command.Name
        @:fun @command.MethodName(@model.GetParameterSignature(command)) {
        @if (command.HasParameter)
        {
            @:    dotnetViewModel.@command.Name.execute(@model.GetParameterName(command))
        }
        else
        {
            @:    dotnetViewModel.@command.Name.execute()
        }
    @:}
        @:
    }
}

    init {
@foreach (var collection in model.Properties.Where(p => p.IsObservableCollection))
{
    @:// Subscribe to ObservableCollection changes for @collection.Name
    @:dotnetViewModel.@collection.Name.collectionChanged += { _, _ ->
    @:    _@collection.CamelCaseName.value = dotnetViewModel.@collection.Name.toList()
    @:}
}
    }

    override fun onCleared() {
        super.onCleared()
        dotnetViewModel.dispose() // Always safe - all ViewModels implement IDisposable
    }
}