using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using x3squaredcircles.SQLSync.Generator.Models;

namespace x3squaredcircles.SQLSync.Generator.Services
{
    public interface ISqlGenerationService
    {
        Task<SqlScript> GenerateDeploymentScriptAsync(DeploymentPlan deploymentPlan, SqlSchemaConfiguration config);
    }

    public class SqlGenerationService : ISqlGenerationService
    {
        private readonly ILogger<SqlGenerationService> _logger;

        public SqlGenerationService(ILogger<SqlGenerationService> logger)
        {
            _logger = logger;
        }

        public async Task<SqlScript> GenerateDeploymentScriptAsync(DeploymentPlan deploymentPlan, SqlSchemaConfiguration config)
        {
            try
            {
                _logger.LogInformation("Generating SQL deployment script for {PhaseCount} phases", deploymentPlan.Phases.Count);

                var provider = config.Database.GetSelectedProvider();
                var scriptBuilder = new StringBuilder();
                var statements = new List<SqlStatement>();

                // Add script header
                GenerateScriptHeader(scriptBuilder, config, deploymentPlan);

                // Generate SQL for each phase
                foreach (var phase in deploymentPlan.Phases.OrderBy(p => p.PhaseNumber))
                {
                    await GeneratePhaseAsync(phase, scriptBuilder, statements, config);
                }

                // Add script footer
                GenerateScriptFooter(scriptBuilder, config);

                var sqlScript = new SqlScript
                {
                    Content = scriptBuilder.ToString(),
                    Statements = statements,
                    GeneratedTime = DateTime.UtcNow,
                    Metadata = new Dictionary<string, object>
                    {
                        ["total_phases"] = deploymentPlan.Phases.Count,
                        ["total_operations"] = deploymentPlan.Phases.Sum(p => p.Operations.Count),
                        ["total_statements"] = statements.Count,
                        ["database_provider"] = provider,
                        ["environment"] = config.Environment.Environment,
                        ["overall_risk_level"] = deploymentPlan.OverallRiskLevel.ToString(),
                        ["generated_by"] = "sql-schema-generator",
                        ["generated_version"] = "1.0.0"
                    }
                };

                _logger.LogInformation("✓ SQL script generated: {StatementCount} statements, {ScriptSize} characters",
                    statements.Count, sqlScript.Content.Length);

                return sqlScript;
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "Failed to generate SQL deployment script");
                throw new SqlSchemaException(SqlSchemaExitCode.SchemaValidationFailure,
                    $"Failed to generate SQL deployment script: {ex.Message}", ex);
            }
        }

        private void GenerateScriptHeader(StringBuilder scriptBuilder, SqlSchemaConfiguration config, DeploymentPlan deploymentPlan)
        {
            var provider = config.Database.GetSelectedProvider();
            var timestamp = DateTime.UtcNow.ToString("yyyy-MM-dd HH:mm:ss UTC");

            scriptBuilder.AppendLine("/*");
            scriptBuilder.AppendLine("================================================================================");
            scriptBuilder.AppendLine("SQL SCHEMA DEPLOYMENT SCRIPT");
            scriptBuilder.AppendLine("================================================================================");
            scriptBuilder.AppendLine($"Generated by:      SQL Schema Generator v1.0.0");
            scriptBuilder.AppendLine($"Generated on:      {timestamp}");
            scriptBuilder.AppendLine($"Database Provider: {provider.ToUpperInvariant()}");
            scriptBuilder.AppendLine($"Target Database:   {config.Database.DatabaseName}");
            scriptBuilder.AppendLine($"Environment:       {config.Environment.Environment.ToUpperInvariant()}");
            scriptBuilder.AppendLine($"Repository:        {config.RepoUrl}");
            scriptBuilder.AppendLine($"Branch:            {config.Branch}");
            scriptBuilder.AppendLine($"Risk Level:        {deploymentPlan.OverallRiskLevel.ToString().ToUpperInvariant()}");
            scriptBuilder.AppendLine($"Total Phases:      {deploymentPlan.Phases.Count}");
            scriptBuilder.AppendLine($"Total Operations:  {deploymentPlan.Phases.Sum(p => p.Operations.Count)}");

            if (deploymentPlan.OverallRiskLevel == RiskLevel.Risky)
            {
                scriptBuilder.AppendLine();
                scriptBuilder.AppendLine("⚠️  WARNING: This deployment contains RISKY operations that may cause data loss!");
                scriptBuilder.AppendLine("    Review all operations carefully before execution.");
                scriptBuilder.AppendLine("    Ensure proper backups are in place.");
            }
            else if (deploymentPlan.OverallRiskLevel == RiskLevel.Warning)
            {
                scriptBuilder.AppendLine();
                scriptBuilder.AppendLine("⚠️  CAUTION: This deployment contains operations that require review.");
            }

            scriptBuilder.AppendLine("================================================================================");
            scriptBuilder.AppendLine("*/");
            scriptBuilder.AppendLine();

            // Add provider-specific settings
            GenerateProviderSpecificSettings(scriptBuilder, provider, config);
        }

        private void GenerateProviderSpecificSettings(StringBuilder scriptBuilder, string provider, SqlSchemaConfiguration config)
        {
            scriptBuilder.AppendLine("-- Database-specific settings");

            switch (provider)
            {
                case "sqlserver":
                    scriptBuilder.AppendLine("SET NOCOUNT ON;");
                    scriptBuilder.AppendLine("SET ANSI_NULLS ON;");
                    scriptBuilder.AppendLine("SET QUOTED_IDENTIFIER ON;");
                    scriptBuilder.AppendLine("SET ANSI_PADDING ON;");
                    scriptBuilder.AppendLine("SET ANSI_WARNINGS ON;");
                    scriptBuilder.AppendLine("SET ARITHABORT ON;");
                    scriptBuilder.AppendLine();
                    scriptBuilder.AppendLine("-- Set command timeout");
                    scriptBuilder.AppendLine($"-- Command timeout: {config.Database.CommandTimeoutSeconds} seconds");
                    break;

                case "postgresql":
                    scriptBuilder.AppendLine("-- PostgreSQL specific settings");
                    scriptBuilder.AppendLine("SET client_encoding = 'UTF8';");
                    scriptBuilder.AppendLine("SET standard_conforming_strings = on;");
                    scriptBuilder.AppendLine("SET check_function_bodies = false;");
                    scriptBuilder.AppendLine("SET xmloption = content;");
                    scriptBuilder.AppendLine("SET client_min_messages = warning;");
                    if (!string.IsNullOrEmpty(config.Database.PostgreSqlSchemaSearchPath))
                    {
                        scriptBuilder.AppendLine($"SET search_path = {config.Database.PostgreSqlSchemaSearchPath};");
                    }
                    break;

                case "mysql":
                    scriptBuilder.AppendLine("-- MySQL specific settings");
                    scriptBuilder.AppendLine("SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0;");
                    scriptBuilder.AppendLine("SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0;");
                    scriptBuilder.AppendLine($"SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE='{config.Database.MySqlEngine}';");
                    scriptBuilder.AppendLine($"SET NAMES {config.Database.MySqlCharset};");
                    break;

                case "oracle":
                    scriptBuilder.AppendLine("-- Oracle specific settings");
                    scriptBuilder.AppendLine("SET DEFINE OFF;");
                    scriptBuilder.AppendLine("SET SERVEROUTPUT ON;");
                    if (!string.IsNullOrEmpty(config.Database.OracleTablespace))
                    {
                        scriptBuilder.AppendLine($"-- Default tablespace: {config.Database.OracleTablespace}");
                    }
                    break;

                case "sqlite":
                    scriptBuilder.AppendLine("-- SQLite specific settings");
                    scriptBuilder.AppendLine("PRAGMA foreign_keys = ON;");
                    scriptBuilder.AppendLine($"PRAGMA journal_mode = {config.Database.SqliteJournalMode};");
                    scriptBuilder.AppendLine($"PRAGMA synchronous = {config.Database.SqliteSynchronous};");
                    break;

                default:
                    throw new NotSupportedException($"Provider-specific settings not implemented for: {provider}");
            }

            scriptBuilder.AppendLine();
        }

        private async Task GeneratePhaseAsync(DeploymentPhase phase, StringBuilder scriptBuilder, List<SqlStatement> statements, SqlSchemaConfiguration config)
        {
            if (!phase.Operations.Any())
            {
                return;
            }

            _logger.LogDebug("Generating SQL for phase {PhaseNumber}: {PhaseName}", phase.PhaseNumber, phase.Name);

            var provider = config.Database.GetSelectedProvider();

            // Phase header
            scriptBuilder.AppendLine($"-- ============================================================================");
            scriptBuilder.AppendLine($"-- PHASE {phase.PhaseNumber}: {phase.Name.ToUpperInvariant()}");
            scriptBuilder.AppendLine($"-- {phase.Description}");
            scriptBuilder.AppendLine($"-- Risk Level: {phase.RiskLevel}");
            scriptBuilder.AppendLine($"-- Operations: {phase.Operations.Count}");
            if (phase.RequiresApproval)
            {
                scriptBuilder.AppendLine($"-- ⚠️  REQUIRES APPROVAL BEFORE EXECUTION");
            }
            scriptBuilder.AppendLine($"-- ============================================================================");
            scriptBuilder.AppendLine();

            // Add transaction handling for the phase
            var useTransaction = ShouldUseTransaction(phase, provider);
            if (useTransaction)
            {
                GenerateBeginTransaction(scriptBuilder, provider, phase.PhaseNumber);
            }

            // Generate error handling
            GenerateErrorHandling(scriptBuilder, provider, phase);

            // Generate operations
            foreach (var operation in phase.Operations)
            {
                await GenerateOperationAsync(operation, scriptBuilder, statements, config, phase.PhaseNumber);
            }

            // Complete transaction
            if (useTransaction)
            {
                GenerateCommitTransaction(scriptBuilder, provider, phase.PhaseNumber);
            }

            scriptBuilder.AppendLine();
            scriptBuilder.AppendLine($"-- Phase {phase.PhaseNumber} completed");
            scriptBuilder.AppendLine();
        }

        private async Task GenerateOperationAsync(DeploymentOperation operation, StringBuilder scriptBuilder, List<SqlStatement> statements, SqlSchemaConfiguration config, int phaseNumber)
        {
            var provider = config.Database.GetSelectedProvider();

            // Operation header
            scriptBuilder.AppendLine($"-- Operation: {operation.Type} {operation.Properties.GetValueOrDefault("object_type", "OBJECT")} {operation.ObjectName}");
            if (!string.IsNullOrEmpty(operation.Properties.GetValueOrDefault("description")?.ToString()))
            {
                scriptBuilder.AppendLine($"-- Description: {operation.Properties["description"]}");
            }
            scriptBuilder.AppendLine($"-- Risk Level: {operation.RiskLevel}");

            // Add dependencies if any
            if (operation.Dependencies.Any())
            {
                scriptBuilder.AppendLine($"-- Dependencies: {string.Join(", ", operation.Dependencies)}");
            }

            scriptBuilder.AppendLine();

            // Generate existence checks for some operations
            if (ShouldGenerateExistenceCheck(operation))
            {
                GenerateExistenceCheck(scriptBuilder, operation, provider);
            }

            // Generate the main SQL command
            if (!string.IsNullOrWhiteSpace(operation.SqlCommand))
            {
                var formattedSql = FormatSqlCommand(operation.SqlCommand, provider);
                scriptBuilder.AppendLine(formattedSql);

                // Create SQL statement for tracking
                var sqlStatement = new SqlStatement
                {
                    Sql = formattedSql,
                    Type = operation.Type,
                    ObjectName = operation.ObjectName,
                    Schema = operation.Schema,
                    RiskLevel = operation.RiskLevel,
                    PhaseNumber = phaseNumber,
                    Properties = new Dictionary<string, object>(operation.Properties)
                };
                statements.Add(sqlStatement);
            }
            else
            {
                scriptBuilder.AppendLine($"-- No SQL command generated for {operation.Type} {operation.ObjectName}");
            }

            // Add rollback information as comments
            if (!string.IsNullOrWhiteSpace(operation.RollbackCommand))
            {
                scriptBuilder.AppendLine();
                scriptBuilder.AppendLine("-- Rollback command:");
                var rollbackLines = operation.RollbackCommand.Split('\n');
                foreach (var line in rollbackLines)
                {
                    scriptBuilder.AppendLine($"-- {line.TrimStart('-', ' ')}");
                }
            }

            scriptBuilder.AppendLine();
            GenerateOperationSeparator(scriptBuilder, provider);
        }

        private bool ShouldUseTransaction(DeploymentPhase phase, string provider)
        {
            // Don't use transactions for backup operations
            if (phase.Operations.Any(op => op.Type == "BACKUP" || op.Type == "VALIDATION"))
            {
                return false;
            }

            // SQLite handles transactions differently
            if (provider == "sqlite")
            {
                return phase.Operations.Count > 1;
            }

            // Use transactions for multi-operation phases
            return phase.Operations.Count > 1;
        }

        private void GenerateBeginTransaction(StringBuilder scriptBuilder, string provider, int phaseNumber)
        {
            scriptBuilder.AppendLine($"-- Begin transaction for Phase {phaseNumber}");

            switch (provider)
            {
                case "sqlserver":
                    scriptBuilder.AppendLine($"BEGIN TRANSACTION Phase{phaseNumber};");
                    break;
                case "postgresql":
                    scriptBuilder.AppendLine("BEGIN;");
                    break;
                case "mysql":
                    scriptBuilder.AppendLine("START TRANSACTION;");
                    break;
                case "oracle":
                    scriptBuilder.AppendLine("-- Oracle uses implicit transactions");
                    break;
                case "sqlite":
                    scriptBuilder.AppendLine("BEGIN TRANSACTION;");
                    break;
                default:
                    throw new NotSupportedException($"Transaction handling not implemented for provider: {provider}");
            }

            scriptBuilder.AppendLine();
        }

        private void GenerateCommitTransaction(StringBuilder scriptBuilder, string provider, int phaseNumber)
        {
            scriptBuilder.AppendLine();
            scriptBuilder.AppendLine($"-- Commit transaction for Phase {phaseNumber}");

            switch (provider)
            {
                case "sqlserver":
                    scriptBuilder.AppendLine($"COMMIT TRANSACTION Phase{phaseNumber};");
                    break;
                case "postgresql":
                case "mysql":
                case "sqlite":
                    scriptBuilder.AppendLine("COMMIT;");
                    break;
                case "oracle":
                    scriptBuilder.AppendLine("COMMIT;");
                    break;
                default:
                    throw new NotSupportedException($"Transaction commit not implemented for provider: {provider}");
            }

            scriptBuilder.AppendLine();
        }

        private void GenerateErrorHandling(StringBuilder scriptBuilder, string provider, DeploymentPhase phase)
        {
            if (phase.RiskLevel == RiskLevel.Safe)
            {
                return; // No special error handling for safe operations
            }

            switch (provider)
            {
                case "sqlserver":
                    scriptBuilder.AppendLine("-- Error handling");
                    scriptBuilder.AppendLine("IF @@ERROR <> 0");
                    scriptBuilder.AppendLine("BEGIN");
                    scriptBuilder.AppendLine($"    ROLLBACK TRANSACTION Phase{phase.PhaseNumber};");
                    scriptBuilder.AppendLine($"    RAISERROR('Phase {phase.PhaseNumber} failed. Transaction rolled back.', 16, 1);");
                    scriptBuilder.AppendLine("    RETURN;");
                    scriptBuilder.AppendLine("END;");
                    break;

                case "postgresql":
                    scriptBuilder.AppendLine("-- Error handling will rollback transaction automatically on error");
                    break;

                case "mysql":
                    scriptBuilder.AppendLine("-- Error handling");
                    scriptBuilder.AppendLine("-- DECLARE CONTINUE HANDLER FOR SQLEXCEPTION ROLLBACK;");
                    break;

                case "oracle":
                    scriptBuilder.AppendLine("-- Error handling");
                    scriptBuilder.AppendLine("-- Use PL/SQL exception handling in procedures");
                    break;

                case "sqlite":
                    scriptBuilder.AppendLine("-- SQLite will rollback automatically on error");
                    break;
            }

            scriptBuilder.AppendLine();
        }

        private bool ShouldGenerateExistenceCheck(DeploymentOperation operation)
        {
            // Generate existence checks for DROP operations to avoid errors
            return operation.Type == "DROP" &&
                   (operation.Properties.GetValueOrDefault("object_type")?.ToString() is "TABLE" or "VIEW" or "PROCEDURE" or "FUNCTION");
        }

        private void GenerateExistenceCheck(StringBuilder scriptBuilder, DeploymentOperation operation, string provider)
        {
            var objectType = operation.Properties.GetValueOrDefault("object_type")?.ToString() ?? "OBJECT";
            var objectName = operation.ObjectName;
            var schema = operation.Schema;

            switch (provider)
            {
                case "sqlserver":
                    GenerateSqlServerExistenceCheck(scriptBuilder, operation, objectType, objectName, schema);
                    break;

                case "postgresql":
                    GeneratePostgreSqlExistenceCheck(scriptBuilder, operation, objectType, objectName, schema);
                    break;

                case "mysql":
                    GenerateMySqlExistenceCheck(scriptBuilder, operation, objectType, objectName, schema);
                    break;

                case "oracle":
                    GenerateOracleExistenceCheck(scriptBuilder, operation, objectType, objectName, schema);
                    break;

                case "sqlite":
                    GenerateSqliteExistenceCheck(scriptBuilder, operation, objectType, objectName);
                    break;

                default:
                    throw new NotSupportedException($"Existence checks not implemented for provider: {provider}");
            }
        }

        private void GenerateSqlServerExistenceCheck(StringBuilder scriptBuilder, DeploymentOperation operation, string objectType, string objectName, string schema)
        {
            var schemaName = schema ?? "dbo";

            switch (objectType.ToUpperInvariant())
            {
                case "TABLE":
                    scriptBuilder.AppendLine($"IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '{schemaName}' AND TABLE_NAME = '{objectName}')");
                    break;
                case "VIEW":
                    scriptBuilder.AppendLine($"IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.VIEWS WHERE TABLE_SCHEMA = '{schemaName}' AND TABLE_NAME = '{objectName}')");
                    break;
                case "PROCEDURE":
                    scriptBuilder.AppendLine($"IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = '{schemaName}' AND ROUTINE_NAME = '{objectName}' AND ROUTINE_TYPE = 'PROCEDURE')");
                    break;
                case "FUNCTION":
                    scriptBuilder.AppendLine($"IF EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = '{schemaName}' AND ROUTINE_NAME = '{objectName}' AND ROUTINE_TYPE = 'FUNCTION')");
                    break;
            }
            scriptBuilder.AppendLine("BEGIN");
        }

        private void GeneratePostgreSqlExistenceCheck(StringBuilder scriptBuilder, DeploymentOperation operation, string objectType, string objectName, string schema)
        {
            var schemaName = schema ?? "public";

            switch (objectType.ToUpperInvariant())
            {
                case "TABLE":
                    scriptBuilder.AppendLine($"DO $$ BEGIN");
                    scriptBuilder.AppendLine($"    IF EXISTS (SELECT 1 FROM information_schema.tables WHERE table_schema = '{schemaName}' AND table_name = '{objectName}') THEN");
                    break;
                case "VIEW":
                    scriptBuilder.AppendLine($"DO $$ BEGIN");
                    scriptBuilder.AppendLine($"    IF EXISTS (SELECT 1 FROM information_schema.views WHERE table_schema = '{schemaName}' AND table_name = '{objectName}') THEN");
                    break;
                case "FUNCTION":
                    scriptBuilder.AppendLine($"DO $$ BEGIN");
                    scriptBuilder.AppendLine($"    IF EXISTS (SELECT 1 FROM information_schema.routines WHERE routine_schema = '{schemaName}' AND routine_name = '{objectName}') THEN");
                    break;
            }
        }

        private void GenerateMySqlExistenceCheck(StringBuilder scriptBuilder, DeploymentOperation operation, string objectType, string objectName, string schema)
        {
            var databaseName = schema; // MySQL uses database name instead of schema

            switch (objectType.ToUpperInvariant())
            {
                case "TABLE":
                    scriptBuilder.AppendLine($"SET @table_exists = (SELECT COUNT(*) FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA = '{databaseName}' AND TABLE_NAME = '{objectName}');");
                    scriptBuilder.AppendLine("SET @sql = IF(@table_exists > 0, 'SELECT 1', 'SELECT 0');");
                    scriptBuilder.AppendLine("PREPARE stmt FROM @sql;");
                    scriptBuilder.AppendLine("EXECUTE stmt;");
                    scriptBuilder.AppendLine("DEALLOCATE PREPARE stmt;");
                    break;
                    // MySQL handling is more complex due to lack of conditional DDL
            }
        }

        private void GenerateOracleExistenceCheck(StringBuilder scriptBuilder, DeploymentOperation operation, string objectType, string objectName, string schema)
        {
            var schemaName = schema ?? "SYSTEM";

            scriptBuilder.AppendLine("DECLARE");
            scriptBuilder.AppendLine("    object_count NUMBER := 0;");
            scriptBuilder.AppendLine("BEGIN");

            switch (objectType.ToUpperInvariant())
            {
                case "TABLE":
                    scriptBuilder.AppendLine($"    SELECT COUNT(*) INTO object_count FROM all_tables WHERE owner = '{schemaName}' AND table_name = '{objectName}';");
                    break;
                case "VIEW":
                    scriptBuilder.AppendLine($"    SELECT COUNT(*) INTO object_count FROM all_views WHERE owner = '{schemaName}' AND view_name = '{objectName}';");
                    break;
            }

            scriptBuilder.AppendLine("    IF object_count > 0 THEN");
        }

        private void GenerateSqliteExistenceCheck(StringBuilder scriptBuilder, DeploymentOperation operation, string objectType, string objectName)
        {
            var sqliteType = objectType.ToLowerInvariant();
            if (sqliteType == "procedure" || sqliteType == "function")
            {
                return; // SQLite doesn't have procedures/functions
            }

            scriptBuilder.AppendLine($"-- Check if {objectType} {objectName} exists");
            // SQLite doesn't have conditional DDL, so we'll use comments to indicate the check
        }

        private string FormatSqlCommand(string sqlCommand, string provider)
        {
            if (string.IsNullOrWhiteSpace(sqlCommand))
            {
                return sqlCommand;
            }

            // Ensure the command ends with a semicolon for most providers
            var trimmed = sqlCommand.TrimEnd();
            if (!trimmed.EndsWith(";") && provider != "oracle") // Oracle sometimes doesn't need semicolons
            {
                trimmed += ";";
            }

            return trimmed;
        }

        private void GenerateOperationSeparator(StringBuilder scriptBuilder, string provider)
        {
            switch (provider)
            {
                case "sqlserver":
                    scriptBuilder.AppendLine("GO");
                    break;
                case "oracle":
                    scriptBuilder.AppendLine("/");
                    break;
                default:
                    // PostgreSQL, MySQL, SQLite don't need special separators
                    break;
            }
            scriptBuilder.AppendLine();
        }

        private void GenerateScriptFooter(StringBuilder scriptBuilder, SqlSchemaConfiguration config)
        {
            var provider = config.Database.GetSelectedProvider();

            scriptBuilder.AppendLine("/*");
            scriptBuilder.AppendLine("================================================================================");
            scriptBuilder.AppendLine("DEPLOYMENT SCRIPT COMPLETED");
            scriptBuilder.AppendLine("================================================================================");
            scriptBuilder.AppendLine($"Script completed at: {DateTime.UtcNow:yyyy-MM-dd HH:mm:ss UTC}");
            scriptBuilder.AppendLine("Please verify all operations completed successfully.");
            scriptBuilder.AppendLine("================================================================================");
            scriptBuilder.AppendLine("*/");
            scriptBuilder.AppendLine();

            // Restore provider-specific settings
            switch (provider)
            {
                case "mysql":
                    scriptBuilder.AppendLine("-- Restore MySQL settings");
                    scriptBuilder.AppendLine("SET SQL_MODE=@OLD_SQL_MODE;");
                    scriptBuilder.AppendLine("SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS;");
                    scriptBuilder.AppendLine("SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS;");
                    break;
            }

            scriptBuilder.AppendLine("-- End of deployment script");
        }
    }
}